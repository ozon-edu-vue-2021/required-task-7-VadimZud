let users; // Массив пользователей, возвращенный с сервера
let idUserMap = {}; // Будет мапить id пользователя в объект с данными о пользователе.
// Это даст мне быстрый поиск пользователя по id, что очень полезно для обработки
// списка друзей.
// Не использую массив, т.к. предполагаю, что id могут быть непоследовательными,
// ненепрерывными и при этом очень большими. Не использую Map, т.к. мне не нужны
// все возможности Map (с которыми, скорее всего, связаны дополнительные
// накладные расходы)
let popularUsers = new Array(3); //Три самых популярных пользователя

function compareByPopularuty(user1, user2) {
    const popularityDiff = user1.popularity - user2.popularity;
    if (popularityDiff) {
        return popularityDiff;
    }
    return user1.name.localeCompare(user2.name);
}

function prepareData(data) {
    users = data;
    // Мапим пользователей по id,
    // плюс задаем начальные значения популярности,
    // чтобы избавиться от лишних проверок на следующем шаге
    users.forEach(user => {
        idUserMap[user.id] = user;
        user.popularity = 0;
    });

    // Вычисляем популярность друзей и подменяем все
    // id на ссылки на структуры user, чтобы в дальнейшем
    // не обращаться лишний раз к idUsersMap.
    // Может показаться, что это можно было бы сделать
    // при предыдущем обходе и не плодить новый,
    // однако только к этому моменту мы имеем полностью
    // сформированный idUserMap и можем полноценно им
    // пользоваться. Мы могли бы, конечно, помещать в idUserMap
    // временный элемент, если сам пользователь там еще
    // не появился, но тогда мы получили бы лишние проверки
    // на каждой итерации, расходы на которые бы, скорее всего,
    // полностью бы перекрыли расходы на еще одну
    // инициализацию forEach.
    users.forEach(user => {
        user.friends = user.friends.map((friendId) => {
            const friend = idUserMap[friendId];
            if (friend) {
                friend.popularity++;
            }
            return friend;
        });
    });

    // Определяем самых популярных пользователей.
    // Эта информация активно не изменяется и нужна в каждой карточке,
    // поэтому можно вычислить её сразу и больше не беспокоиться об этом
}

fetch("data.json")
    .then(response => response.json())
    .then(data => )